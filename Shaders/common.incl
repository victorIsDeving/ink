#version 330 core

vec2 R;
float time;
// The code is not optimized for speed; it turns out programming with integers can be slow on some GPU's.
// The reason I still use them is readability of the code.



const ivec2 FS_ADDR = ivec2(0.0);

const vec4 fs_stt = vec4(1.0);

uint seed = 0u;

void setSeed(uint s) {
    seed = s;
}

uint hash(uint s) {
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

uint randI() {
    seed = hash(seed);
    return seed;
}

float rand() {
    uint rn = randI();
    rn %= 1000000000u;
    float rs = float(rn);
    rs /= 1000000000.0;
    return rs;
}

#define setNSeed() setSeed(uint(iResolution.x*gl_FragCoord.y+gl_FragCoord.x + float(hash(uint(iTime*1000.0))%1000u)))



#define N(v) (v.yx*vec2(1,-1))
//amount of particles
 //int PARTICLES = 11000;
float Pp= 1.0;
//percentage of maximum allowed speed
const float SPEED = 1.13;

//hashing noise by IQ
float hash( int k,float iTime ) {
    float l =k*iTime;
    uint n = uint(l);
        n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 789221U) + 1376312589U;
    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;
}

#define PI 3.1415927
#define PIOVERTWO 1.57079633
#define TWOPI 6.28318530718
#define PNUM 200
vec2 Res;
#define STROKE_THICKNESS (min(Res.x,Res.y)/500.)
#define GRADIENT_EPS 1

struct Particle {
    vec2 pos;
    vec2 vel;
    int idx;
};

int particleIdx(vec2 coord, sampler2D s)
{
    ivec2 ires=textureSize(s,0);
    return int(coord.x)+int(coord.y)*ires.x;
}

vec2 particleCoord(int idx, sampler2D s)
{
    ivec2 ires=textureSize(s,0);
    return vec2(idx%ires.x,idx/ires.x)+.5;
}

vec4 getPixel(vec2 coord, sampler2D s)
{
    return texelFetch(s,ivec2(coord),0);
}

void readParticle(inout Particle p, vec2 coord, sampler2D s)
{
    vec4 pix=getPixel(coord,s);
    p.pos=pix.xy;
    p.vel=pix.zw;
    p.idx=particleIdx(coord,s);
}

void readParticle(inout Particle p, int idx, sampler2D s)
{
    readParticle(p,particleCoord(idx,s),s);
}

int n_PARTICLES = int(Res.x*Res.y*Pp);

uint pack(vec2 x)
{
    vec2 xx =clamp(x/n_PARTICLES,0., 1.);
    xx=65534.0*xx;//clamp(0.5*x+0.5, 0., 1.);
    return uint(round(xx.x)) + 65535u*uint(round(xx.y));
}

vec2 unpack(uint a)
{
    vec2 x = vec2(a%65535u, a/65535u);
    return clamp(x/65534.0, 0.,1.);
}

vec2 decode(float x)
{
    uint X = floatBitsToUint(x);
    return unpack(X);
}

float encode(vec2 x)
{
    uint X = pack(x);
    return uintBitsToFloat(X);
}



void getParticle(vec4 data, inout ivec4 ids[2])
{

    ids[0].xy = ivec2(n_PARTICLES*decode(data.x));
    ids[0].zw = ivec2(n_PARTICLES*decode(data.y));
    ids[1].xy = ivec2(n_PARTICLES*decode(data.z));
    ids[1].zw = ivec2(n_PARTICLES*decode(data.w));

}

vec4 saveParticle( ivec4 ids[2])
{

    return vec4(encode(vec2(ids[0].xy)), encode(vec2(ids[0].zw)), encode(vec2(ids[1].xy)), encode(vec2(ids[1].zw)));
}

void writeParticle(Particle p, inout vec4 col, vec2 coord, sampler2D s)
{
    if (particleIdx(coord,s)%PNUM==p.idx) col=vec4(p.pos,p.vel);
}

vec4 getRand(vec2 pos, sampler2D s)
{
    vec2 rres=vec2(textureSize(s,0));
    return textureLod(s,pos/rres,0.);
}

vec4 getRand(int idx, sampler2D s)
{
    ivec2 rres=textureSize(s,0);
    idx=idx%(rres.x*rres.y);
    return texelFetch(s,ivec2(idx%rres.x,idx/rres.x),0);
}

void initParticle(inout Particle p, sampler2D s, sampler2D sr, int frame)
{
    vec2 res=vec2(textureSize(s,0));
    int NUM_X=int(res.x);
    int NUM_Y=int(res.y);
    //p.pos = vec2((p.idx/2)%NUM_X,(p.idx/2)/NUM_X)*res/vec2(NUM_X,NUM_Y);
    p.pos=getRand(frame+p.idx,sr).xy*res.xy;
    p.vel = (getRand(p.pos,sr).xy-.5)*(float(p.idx%2)-.5)*300.;
}

vec4 getCol(vec2 pos, sampler2D s, vec2 res)
{
    return textureLod(s,pos/res.xy,0.);
}

float getVal(vec2 pos, vec2 res,sampler2D s)
{
    return dot(getCol(pos,s,res).xyz,vec3(0.2126, 0.7152, 0.0722));
}

vec4 getGray(vec2 fragCoord,vec2 res,sampler2D s)
{
    vec2 uv = fragCoord/res;
    vec3 col = texture(s, uv).xyz;
    float noise = 0.;
    int range = 2;
    for(int i = int(fragCoord.x) - range; i <= int(fragCoord.x) + range; i++){
        for(int j = int(fragCoord.y) - range; j <= int(fragCoord.y) + range; j++){
            vec3 p = texture(s, vec2(i, j) / res).xyz;
            noise += pow(col.x - p.x, 2.) + pow(col.y - p.y, 2.) + pow(col.z - p.z, 2.);
        }
    }
    noise/=5.;
    //1.73205080757;
    //noise= smoothstep(0,1.73205080757,noise);


    return vec4((vec3(noise)), 1.);
}

vec2 getGrad(vec2 pos, float eps, sampler2D s, vec2 res)
{
    vec2 d=vec2(eps,0.);
    return vec2(
        getVal(pos+d.xy,res,s)-getVal(pos-d.xy,res,s),
        getVal(pos+d.yx,res,s)-getVal(pos-d.yx,res,s)
        )/GRADIENT_EPS/2.;
}
vec2 gradient(sampler2D img, vec2 pt,ivec2 iRes) {
    float coeffs[16] = float[16](
        1./6., -1./2., 1./2., -1./6.,
        2./3., 0., -1., 1./2.,
        1./6., 1./2., 1./2., -1./2.,
        0., 0., 0.0, 1./6.
    );
    vec2 fr = fract(pt);
    ivec2 coord = ivec2(pt);
    coord.y= iRes.y-coord.y;
    vec2 grad = vec2(0.0);
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            vec2 t = vec2(1.);
            vec2 B = vec2(0.);
            vec2 dB = vec2(0.);
            for (int k = 0; k < 4; k++) {
                vec2 coeff = vec2(coeffs[i*4+k], coeffs[j*4+k]);
                B += t * coeff;
                dB += float(k) * pow(fr, vec2(float(k)-1.)) * coeff;
                t *= fr;
            }
            vec2 smp = texelFetch(img, coord + ivec2(i-1, j-1), 0).xy;
            grad += smp * (dB.xy * B.yx);
        }
    }
    return grad;
}


//  Vertices and edge midpoints: Clockwise from the bottom left. -- Basically, the ones
// above rotated anticlockwise. :)
vec2[6] vID = vec2[6](vec2(-.5, -2./6.)/vec2(.5, 1), vec2(-.5, 2./6.)/vec2(.5, 1), vec2(0, 2./3.)/vec2(.5, 1),
                      vec2(.5, 2./6.)/vec2(.5, 1), vec2(.5, -2./6.)/vec2(.5, 1), vec2(0, -2./3.)/vec2(.5, 1));
//vec2[6] eID = vec2[6](vec2(-.5, 0)/vec2(.5, 1), vec2(-.25, .5)/vec2(.5, 1), vec2(.25, .5)/vec2(.5, 1),
                      //vec2(.5, 0)/vec2(.5, 1),
                      //vec2(.25, -.5)/vec2(.5, 1), vec2(-.25, -.5)/vec2(.5, 1));


// Standard 2D rotation formula.
mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }


// IQ's vec2 to float hash.
float hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }


// Unsigned distance to the segment joining "a" and "b".
float distLine(vec2 a, vec2 b){

        b = a - b;
        float h = clamp(dot(a, b)/dot(b, b), 0., 1.);
    return length(a - b*h);
}

// IQ's box formula -- Modified slightly.
float sBoxS(in vec2 p, in vec2 b, in float rf){


vec2 d = abs(p) - b + rf;
return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;

}

// IQ's box formula.
float sBox(in vec2 p, in vec2 b){

vec2 d = abs(p) - b;
return min(max(d.x, d.y), 0.) + length(max(d, 0.));
}

// This renders a horizontal or vertical box-line from point "a" to point "b," with a line
// width of "w." It's different to the the usual line formula because it doesn't render the
// rounded caps on the end -- Sometimes, you don't want those. It utilizes IQ's box formula
// and was put together in a hurry, so I'd imagine there are more efficient ways to do the
// same, but it gets the job done. I put together a more generalized angular line formula as
// well.
float lBoxHV(vec2 p, vec2 a, vec2 b, float w){

 vec2 l = abs(b - a); // Box-line length.
 p -= vec2(mix(a.x, b.x, .5), mix(a.y, b.y, .5)); // Positioning the box center.

 // Applying the above to IQ's box distance formula.
 vec2 d = abs(p) - (l + w)/2.;
 return min(max(d.x, d.y), 0.) + length(max(d, 0.));
}

// This will draw a box (no caps) of width "ew" from point "a "to "b". I hacked
// it together pretty quickly. It seems to work, but I'm pretty sure it could be
// improved on. In fact, if anyone would like to do that, I'd be grateful. :)
float lBox(vec2 p, vec2 a, vec2 b, float ew){

  float ang = atan(b.y - a.y, b.x - a.x);
  p = rot2(ang)*(p - mix(a, b, .5));

 vec2 l = vec2(length(b - a), ew);
 return sBox(p, (l + ew)/2.) ;
}

// IQ's distance to a regular pentagon, without trigonometric functions.
// Other distances here:
// https://iquilezles.org/articles/distfunctions2d
//
#define NV2 4
//
float sdPoly4(in vec2 p, in vec2[NV2] v){

  const int num = v.length();
  float d = dot(p - v[0],p - v[0]);
  float s = 1.0;
  for( int i = 0, j = num - 1; i < num; j = i, i++){

      // distance
      vec2 e = v[j] - v[i];
      vec2 w =    p - v[i];
      vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );
      d = min( d, dot(b,b) );

      // winding number from http://geomalgorithms.com/a03-_inclusion.html
      bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );
      if( all(cond) || all(not(cond)) ) s*=-1.0;
  }

  return s*sqrt(d);
}

// Signed distance to a regular hexagon -- using IQ's more exact method.
float sdHexagon(in vec2 p, in float r){

const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.

// X and Y reflection.
p = abs(p);
p -= 2.*min(dot(k.xy, p), 0.)*k.xy;

// Polygon side.
return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r);

}

// Determines which side of a line a pixel is on. Zero is the threshold.
float line(vec2 p, vec2 a, vec2 b){
   return ((b.x - a.x)*(p.y - a.y) - (b.y - a.y)*(p.x - a.x));
}

/*
// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's
// original. Very trimmed down. In fact, I probably went a little overboard. I think it
// might also degrade with large time values.
float n2D(vec2 p) {

      vec2 i = floor(p); p -= i; p *= p*(3. - p*2.);

      return dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*
             vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );

}
*/

// Compact, self-contained version of IQ's 2D value noise function.
float n2D(vec2 p){

  // Setup.
  // Any random integers will work, but this particular
  // combination works well.
  const vec2 s = vec2(1, 113);
  // Unique cell ID and local coordinates.
  vec2 ip = floor(p); p -= ip;
  // Vertex IDs.
  vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);

  // Smoothing.
  p = p*p*(3. - 2.*p);
  //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.

  // Random values for the square vertices.
  h = fract(sin(h)*43758.5453);

  // Interpolation.
  h.xy = mix(h.xy, h.zw, p.y);
  return mix(h.x, h.y, p.x); // Output: Range: [0, 1].
}

// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.
float fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }


vec3 pencil(vec3 col, vec2 p){

  // Rough pencil color overlay... The calculations are rough... Very rough, in fact,
  // since I'm only using a small overlayed portion of it. Flockaroo does a much, much
  // better pencil sketch algorithm here:
  //
  // When Voxels Wed Pixels - Flockaroo
  // https://www.shadertoy.com/view/MsKfRw
  //
  // Anyway, the idea is very simple: Render a layer of noise, stretched out along one
  // of the directions, then mix similar, but rotated, layers on top. Whilst doing this,
  // compare each layer to it's underlying greyscale value, and take the difference...
  // I probably could have described it better, but hopefully, the code will make it
  // more clear. :)
  //
  // Tweaked to suit the brush stroke size.
  vec2 q = p*4.;
  const vec2 sc = vec2(1, 12);
  q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;
  q *= rot2(-3.14159/2.5);
  // I always forget this bit. Without it, the grey scale value will be above one,
  // resulting in the extra bright spots not having any hatching over the top.
  col = min(col, 1.);
  // Underlying grey scale pixel value -- Tweaked for contrast and brightness.
  float gr = (dot(col, vec3(.299, .587, .114)));
  // Stretched fBm noise layer.
  float ns = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);
  //
  // Repeat the process with a couple of extra rotated layers.
  q *= rot2(3.14159/2.);
  float ns2 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);
  q *= rot2(-3.14159/5.);
  float ns3 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);
  //
  // Compare it to the underlying grey scale value.
  //
  // Mix the two layers in some way to suit your needs. Flockaroo applied common sense,
  // and used a smooth threshold, which works better than the dumb things I was trying. :)
  const float contrast = 1.;
  ns = (.5 + (gr - (max(max(ns, ns2), ns3)))*contrast); // Same, but with contrast.
  //ns = smoothstep(0., 1., .5 + (gr - max(max(ns, ns2), ns3))); // Different contrast.
  //
  // Return the pencil sketch value.
  return vec3(clamp(ns, 0., 1.));

}

// get ids in a cyclic order to i,j neigbourg elements
#define ID_POS(x) clamp(abs(4.-8.*fract(vec2(x+3,x-3)/8.))-2.,-1.,1.)

// https://iquilezles.org/articles/distfunctions2d
float sdSegment( in vec2 p, in vec2 a, in vec2 b )
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);
    return length(pa - ba*h);
}

// https://iquilezles.org/articles/distfunctions2d
float sdBox( in vec2 p, in vec2 b) {
    vec2 d = abs(p)-b;
    return length(max(d,0.)) + min(max(d.x,d.y),0.);
}

// iq: https://www.shadertoy.com/view/wdBXRW
float sdPolygon(in vec2 p, in vec2[8] v, int num ) {
    float s = 1., d = dot(p-v[0],p-v[0]);
    for( int i=0, j=num-1; i<num; j=i, i++ ) {
        vec2 e = v[j] - v[i], w = p - v[i],
             b = w - e*clamp( dot(w,e)/dot(e,e), 0., 1.);
        d = min(d, dot(b,b));
        bvec3 cond = bvec3(p.y>=v[i].y, p.y <v[j].y,  e.x*w.y>e.y*w.x );
        if (all(cond) || all(not(cond))) s=-s;
    }
    return s*sqrt(d);
}

// basic line line intersection
vec2 intersect(vec2 p0, vec2 n0, vec2 p1, vec2 n1) {
    float d = n0.x*n1.y-n0.y*n1.x; // 0 if paralelle but does not append here
    vec2 p = (p0-p1)/d;
    return vec2(p.y*n1.x-p.x*n1.y, p.y*n0.x-p.x*n0.y);
}


// https://www.geeksforgeeks.org/minimum-enclosing-circle-set-1/

float INF = 1e5;

// Function to check whether a vec2 lies inside
// or on the boundaries of the vec3
bool isInside(vec3 c, vec2 p) {
    return distance(c.xy, p) <= c.z;
}

// Function to return the smallest vec3
// that intersects 2 Points
vec3 circleFrom(vec2 A, vec2 B) {
    vec2 C = .5*(A+B); // Set the center to be the midPoint of A and B
    return vec3(C, distance(A,B)*.5); // Set the radius to be half the distance AB
}


// The following two functions are the functions used
// To find the equation of the vec3 when three Points are given.
// Helper method to get a vec3 defined by 3 Points
vec2 getCircleCenter(vec2 b, vec2 c) {
    float B = dot(b,b),
          C = dot(c,c),
          D = b.x * c.y - b.y * c.x;
     return vec2(c.y*B-b.y*C, b.x*C-c.x*B) / (D+D);
}

// Function to return a unique vec3 that intersects
// three Points
vec3 circleFrom(vec2 A, vec2 B, vec2 C) {
    vec2 I = getCircleCenter(B-A,C-A) + A;
    return vec3(I, distance(I, A));
}

// Function to check whether a vec3 encloses the given Points
bool isValidCircle(vec3 c, vec2[8] P, int num) {
    // Iterating through all the Points to check
    // whether the Points lie inside the vec3 or not
    for (int i=0; i<num; i++)
        if (distance(c.xy, P[i]) > c.z+1e-2)
            return false;
    return true;
}

// Function to return find the minimum enclosing
// vec3 from the given set of Points
vec3 minimumEnclosingCircle(vec2[8] P, int n) {
    if (n == 0) return vec3(0);
    if (n == 1) return vec3(P[0],0);

    vec3 mec = vec3(0,0,INF);
    // Go over all pair of Points
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
              // Get the smallest circle that intersects P[i] and P[j]
            vec3 tmp = circleFrom(P[i], P[j]);
            // Update MEC if tmp encloses all Points and has a smaller radius
            if (tmp.z < mec.z && isValidCircle(tmp, P, n))
                mec = tmp;
        }
    }

    // Go over all triples of Points
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            for (int k = j + 1; k < n; k++) {
                // Get the vec3 that intersects P[i], P[j], P[k]
                vec3 tmp = circleFrom(P[i], P[j], P[k]);
                // Update MEC if tmp encloses all Points and has smaller radius
                if (tmp.z < mec.z && isValidCircle(tmp, P, n))
                    mec = tmp;
            }
        }
    }
    return mec;
}

// does not calculate sign
float sdPoly(in vec2 p, in vec2[8] v, int num ) {
    float d = dot(p-v[0],p-v[0]);
    for(int i=0, j=num-1; i<num; j=i, i++ ) {
        vec2 e = v[j] - v[i], w = p - v[i],
             b = w - e*clamp(dot(w,e)/dot(e,e), 0., 1.);
        d = min(d, dot(b,b));
    }
    return -sqrt(d);
}

#define NB_ITER 14
// Not very acurate
vec3 findInscribeCircle(vec2[8] P, int n) {
    vec2 p0,p=P[0]; // p0 to avoid too much occilation
    for (int i=1; i<n; i++) p+=P[i];
    p0 = p/=float(n); // start at mass center of points
    // find scale of polygon
    float d, len = 1e5;
    for (int i=1; i<n; i++) if ((d=distance(p,P[i]))<len) len = d;
    // gradiant descent to find min value of distance field
    float dt = .4*len;
    vec2 dd = vec2(.1*dt,0);
    for (int i=0; i<NB_ITER; i++) {
        p0 = p;
        p -= dt*normalize(vec2(sdPoly(p+dd,P,n)    - sdPoly(p-dd,P,n),
                               sdPoly(p+dd.yx,P,n) - sdPoly(p-dd.yx,P,n)));
        dt *= .8;
    }
    return vec3((p+p0)*.5, -sdPolygon((p+p0)*.5, P, n));
}



vec2 hash2(vec2 p)
{
    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.64));
    a+=dot(a,a+34.45);
    return fract(vec2(a.x*a.z,a.y*a.z));
}

//-----------------------------------
// Minimalist voronoi distance for one cell
// Inexact outside of cells
// Generalisable to 3D cells
//-----------------------------------
vec3 sdVoronoiCell(in vec2 p, in vec2 cellId ) {
    float md = 8.0;
    vec2 mr = hash2(cellId);
    for(int i=0; i<8; i++) {
        vec2 g = ID_POS(i),
             r = g + hash2(cellId + g);
        md = min(md, dot(.5*(mr+r)-p, normalize(r-mr)));
    }
    return vec3(-md, mr-p);
}

//-----------------------------------
// Indicate if a point is inside a voronoi cell
//-----------------------------------
bool isInsideVoronoiCell(in vec2 p, in vec2 cellId) {
    float dm = length(hash2(cellId)-p);
    for(int i=0; i<8; i++) {
        vec2 g = ID_POS(i),
             r = g + hash2(cellId + g);
        if (length(r-p) < dm) return false;
    }
    return true;
}

//-----------------------------------
// Draw construction lines on voronoi
//-----------------------------------
vec3 drawVoronoiLines(in vec2 p, in vec2 cellId) {
    vec2 rm = hash2(cellId); // center of cell
    vec3 d = vec3(999.);
    for(int i=0; i<8; i++) {
        vec2 g = ID_POS(i),                     // relative pos of neigbourg cell
             r = g + hash2(cellId + g),         // center of the neigbourg cell
             n = r - rm,
             c = rm + n*.5;                     // ref pt between cells
        n = normalize(vec2(-n.y,n.x));          // normal on the edge
        d = min(d, vec3(length(c-p),            // distance to the
                        sdSegment(p,r,rm),      // distance to segment between cells
                        sdSegment(p,c+n,c-n))); // distance to edge of cell
    }
    return d;
}

//-----------------------------------
// Extract voronoi cell polygon
//-----------------------------------
vec2[8] getVoronoiPolygon(in vec2 p, in vec2 cellId, out int out_sz) {
        vec2 rm = hash2(cellId); // center of cell
    vec2 c[8], n[8];
    // Get liste of lines
    for(int i=0; i<8; i++) {
        vec2 g0 = ID_POS(i),
             r0 = g0 + hash2(cellId + g0),  // centre de l'autre cellule
             n0 = r0 - rm;
         c[i] = rm + n0*.5;  // Pt entre les 2 cellules
         n[i] = normalize(vec2(-n0.y,n0.x));
    }
    // Find intersection between lines
    vec4 seg[8]; // x:-2 y:-1 z:+1 w:+2
    for(int i=2; i<10; i++) { // Intersection point with two previous lines
        vec2 t1 = intersect(c[i%8], n[i%8], c[(i-1)%8], n[(i-1)%8]),
             t2 = intersect(c[i%8], n[i%8], c[(i-2)%8], n[(i-2)%8]);
        seg[i%8].x = t2.x;     // -2 of seg  0
        seg[i%8].y = t1.x;     // -1 of seg  0
        seg[(i-1)%8].z = t1.y; // +1 of seg -1
        seg[(i-2)%8].w = t2.y; // +2 of seg -2
    }
    // Reconstruct the polygon
    out_sz = 0;
    for(int i=0; i<8; i++) {
        float dmin = max(seg[i].z,seg[i].w);
        if (dmin < min(seg[i].x,seg[i].y)) { // skip useless segments
            n[out_sz] = c[i]+dmin*n[i];
            out_sz++;
        }
    }
    return n;
}

void insertion_sort(inout ivec4 i[2], inout vec4 d[2], int i_, float d_){
    if(any(equal(ivec4(i_),i[0]))||(any(equal(ivec4(i_),i[1])))) return;
    if     (d_ < d[0][0])
        i[0] = ivec4(i_,i[0].xyz),    d[0] = vec4(d_,d[0].xyz);
    else if(d_ < d[0][1])
        i[0] = ivec4(i[0].x,i_,i[0].yz), d[0] = vec4(d[0].x,d_,d[0].yz);
    else if(d_ < d[0][2])
        i[0] = ivec4(i[0].xy,i_,i[0].z), d[0] = vec4(d[0].xy,d_,d[0].z);
    else if(d_ < d[0][3])
        i[0] = ivec4(i[0].xyz,i_),    d[0] = vec4(d[0].xyz,d_);
    else if (d_ < d[1][0])
        i[1] = ivec4(i_,i[1].xyz),    d[1] = vec4(d_,d[1].xyz);
    else if(d_ < d[1][1])
        i[1] = ivec4(i[1].x,i_,i[1].yz), d[1] = vec4(d[1].x,d_,d[1].yz);
    else if(d_ < d[1][2])
        i[1] = ivec4(i[1].xy,i_,i[1].z), d[1] = vec4(d[1].xy,d_,d[1].z);
    else if(d_ < d[1][3])
        i[1] = ivec4(i[1].xyz,i_),    d[1] = vec4(d[1].xyz,d_);
}


